#include <iostream>
#include <vector>
#include <thread>
#include <mutex>
#include <random>
#include <chrono>

using namespace std;
using namespace std::chrono;

mutex mtx; 
unsigned fideos = 100;
class Filosofo {

private:

    int id;

    unsigned int estomago;
    thread filosofoThread;

public:

    Filosofo(int filosofid) : id(filosofid), estomago(0) {}

    void pensar() {
        random_device rd;
        mt19937 gen(rd());
        uniform_int_distribution<int> distribution(1, 5);

        int tiempoPensando = distribution(gen);
        this_thread::sleep_for(seconds(tiempoPensando));
    }

    void comer(){
        random_device rd;
        mt19937 gen(rd());
        uniform_int_distribution<int> distribution(1, 3);

        int tiempoComiendo = distribution(gen);
        this_thread::sleep_for(seconds(tiempoComiendo));

        mtx.lock();
        if (fideos > 0) {
            fideos--;
            estomago++;
            cout << "Filosofo " << id << " comiendo... Estomago: " << estomago << endl;
    }
    
    void ejecutar(){
        while (fideos > 0) {
            pensar();
            comer();
        }
    }
    
    void iniciar_filosofos(){
        filosofoThread = thread(&Filosofo::ejecutar, this);
    {
    
    void unirse() {
        filosofoThread.join();
    }

    unsigned int obtenerEstomago() {
        return estomago;
    }
};
    //void mostrar_estadisticas(){ }
    
    int main() {
    const int numFilosofos = 5;

    vector<Filosofo> filosofos;
    for (int i = 0; i < numFilosofos; i++) {
        filosofos.push_back(Filosofo(i));
    }

    vector<thread> threads;
    for (int i = 0; i < numFilosofos; i++) {
        threads.push_back(thread(&Filosofo::iniciar, &filosofos[i]));
    }

    for (int i = 0; i < numFilosofos; i++) {
        threads[i].join();
    }

    cout << "Estado del plato de fideos: " << fideos << endl;
    for (int i = 0; i < numFilosofos; i++) {
        cout << "Filosofo " << i << ": Estomago: " << filosofos[i].obtenerEstomago() << endl;
    }

    return 0;
}

