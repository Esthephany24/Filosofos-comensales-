#include <iostream>
#include <vector>
#include <thread>
#include <mutex>
#include <random>
#include <chrono>
#include <condition_variable>//Sincronizacin que se puede utilizar para bloquear un subproceso

const int MAX_PENSAR = 500; // Tiempo mximo para pensar (milisegundos)
const int MAX_COMER = 500; // Tiempo mximo para comer (milisegundos)
const int MAX_FIDEOS = 10; // Cantidad inicial de fideos en el plato

std::mutex mtx; // Mutex para proteger acceso al plato de fideos

// estruct para representar a un filosofo
struct Filosofo {
    int estomago; // estomago del filosofo

    void pensar() {
        std::random_device rd;
        std::mt19937 gen(rd());
        std::uniform_int_distribution<> dis(1, MAX_PENSAR);
        int tiempo = dis(gen);
        std::this_thread::sleep_for(std::chrono::milliseconds(tiempo));
    }

    void comer() {
        std::random_device rd;
        std::mt19937 gen(rd());
        std::uniform_int_distribution<> dis(1, MAX_COMER);
        int tiempo = dis(gen);
        std::this_thread::sleep_for(std::chrono::milliseconds(tiempo));
        estomago++;
    }
};


    void ejecutar(){
        while (fideos > 0) {
            pensar();
            comer();
        }
    }
    
    void iniciar_filosofos(){
        filosofoThread = thread(&Filosofo::ejecutar, this);
    {
    
    void unirse() {
        filosofoThread.join();
    }

    unsigned int obtenerEstomago() {
        return estomago;
    }
};
    //void mostrar_estadisticas(){ }
    
    int main() {
    const int numFilosofos = 5;

    vector<Filosofo> filosofos;
    for (int i = 0; i < numFilosofos; i++) {
        filosofos.push_back(Filosofo(i));
    }

    vector<thread> threads;
    for (int i = 0; i < numFilosofos; i++) {
        threads.push_back(thread(&Filosofo::iniciar, &filosofos[i]));
    }

    for (int i = 0; i < numFilosofos; i++) {
        threads[i].join();
    }

    cout << "Estado del plato de fideos: " << fideos << endl;
    for (int i = 0; i < numFilosofos; i++) {
        cout << "Filosofo " << i << ": Estomago: " << filosofos[i].obtenerEstomago() << endl;
    }

    return 0;
}

